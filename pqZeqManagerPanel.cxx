#include "pqZeqManagerPanel.h"
//
#include <boost/bind.hpp>

// Qt includes
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QVariant>
#include <QLabel>
#include <QComboBox>
#include <QTableWidget>
#include <QMessageBox>
#include <QProgressDialog>
#include <QTimer>
#include <QInputDialog>
#include <QFileDialog>
#include <QUrl>
#include <QDesktopServices>
#include <QThread>

// VTK includes

// ParaView Server Manager includes
#include "vtkSMInputProperty.h"
#include "vtkSMProxyManager.h"
#include "vtkSMSourceProxy.h"
#include "vtkSMStringVectorProperty.h"
#include "vtkSMIntVectorProperty.h"
#include "vtkSMArraySelectionDomain.h"
#include "vtkSMProxyProperty.h"
#include "vtkSMViewProxy.h"
#include "vtkSMRepresentationProxy.h"
#include "vtkSMPropertyHelper.h"
#include "vtkProcessModule.h"
#include "vtkClientServerStream.h"
#include "vtkSMSession.h"

// ParaView includes
#include "pqActiveObjects.h"
#include "pqApplicationCore.h"
#include "pqAutoGeneratedObjectPanel.h"
#include "pqSettings.h"
#include "pqOutputPort.h"
#include "pqPipelineSource.h"
#include "pqPropertyLinks.h"
#include "pqProxy.h"
#include "pqServer.h"
#include "pqServerManagerModelItem.h"
#include "pqServerManagerModel.h"
#include "pqSMAdaptor.h"
#include "pqTreeWidgetCheckHelper.h"
#include "pqTreeWidgetItemObject.h"
#include "pqTreeWidget.h"
#include "pqTreeWidgetItem.h"
#include "pqView.h"
#include "pqRenderView.h"
#include "pqDataRepresentation.h"
#include "pqDisplayPolicy.h"
#include "pqAnimationScene.h"
#include "pqPropertyManager.h"
#include "pqNamedWidgets.h"
//
#include <QTcpServer>
#include <QTcpSocket>
#include <QStringListModel>
//
#include "ui_pqZeqManagerPanel.h"
//
#include "vtkZeqManager.h"
#include <zeq/vocabulary.h>
#include <monsteer/spikes_zeq_generated.h>
//
#include <vector>
#include <regex>
//
//----------------------------------------------------------------------------
class StringList : public QStringListModel
{
public:
  void append (const QString& string){
    insertRows(rowCount(), 1);
    setData(index(rowCount()-1), string);
  }
  StringList& operator<<(const QString& string){
    append(string);
    return *this;
  }
};

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
class pqZeqManagerPanel::pqInternals : public QObject, public Ui::ZeqManagerPanel
{
public:
  pqInternals(pqZeqManagerPanel* p) : QObject(p)
  {
    this->Links = new pqPropertyLinks;
    this->clientOnlyZeqManager = NULL;
    event_num = 0;
  }
  //
  ~pqInternals() {
    delete this->Links;
    if (this->clientOnlyZeqManager) {
      this->clientOnlyZeqManager->Delete();
    }
  }
  //
  pqPropertyLinks         *Links;
  QTcpServer*              TcpNotificationServer;
  QTcpSocket*              TcpNotificationSocket;
  StringList               listModel;
  static int               event_num;
  vtkZeqManager           *clientOnlyZeqManager;
};
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
int pqZeqManagerPanel::pqInternals::event_num = 0;
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
pqZeqManagerPanel::pqZeqManagerPanel(pqProxy* proxy, QWidget* p) :
  pqNamedObjectPanel(proxy, p) 
{
  this->Internals = new pqInternals(this);
  this->Internals->setupUi(this);

  // inherited from pqNamedObjectPanel
  this->linkServerManagerProperties();
  
  this->connect(this->Internals->start,
    SIGNAL(clicked()), this, SLOT(onStart()));

  //
  this->connect(this, SIGNAL(onaccept()), this, SLOT(onAccept()));

  // Create a new notification socket to send events from server to client
  this->Internals->TcpNotificationServer = new QTcpServer(this);
  this->connect(this->Internals->TcpNotificationServer,
    SIGNAL(newConnection()), SLOT(onNewNotificationSocket()));
  this->Internals->TcpNotificationServer->listen(QHostAddress::Any,
    VTK_ZEQ_MANAGER_DEFAULT_NOTIFICATION_PORT);
}
//----------------------------------------------------------------------------
pqZeqManagerPanel::~pqZeqManagerPanel()
{
}
//-----------------------------------------------------------------------------
void pqZeqManagerPanel::LoadSettings()
{
  pqSettings *settings = pqApplicationCore::instance()->settings();
  settings->beginGroup("ZeqManager");

  // Autostart
  this->Internals->autostart->setChecked(settings->value("autostart", true).toBool());
  // mode
  this->Internals->zeq_both->setChecked(settings->value("zeq_both", true).toBool());
  this->Internals->zeq_gui->setChecked(settings->value("zeq_gui", true).toBool());
  this->Internals->zeq_server->setChecked(settings->value("zeq_server", true).toBool());
  settings->endGroup();
}
//----------------------------------------------------------------------------
void pqZeqManagerPanel::SaveSettings()
{
  pqSettings *settings = pqApplicationCore::instance()->settings();
  settings->beginGroup("ZeqManager");

  // Autostart
  settings->setValue("autostart", this->Internals->autostart->isChecked());
  // mode
  settings->setValue("zeq_both", this->Internals->zeq_both->isChecked());
  settings->setValue("zeq_gui", this->Internals->zeq_gui->isChecked());
  settings->setValue("zeq_server", this->Internals->zeq_server->isChecked());
  settings->endGroup();
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::AutoStart()
{
  if (this->Internals->autostart->isChecked()) {
    this->onStart();
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onNewNotificationSocket()
{
  this->Internals->TcpNotificationSocket =
  this->Internals->TcpNotificationServer->nextPendingConnection();

  if (this->Internals->TcpNotificationSocket) {
    this->connect(this->Internals->TcpNotificationSocket,
                  SIGNAL(readyRead()), SLOT(onNotified()), Qt::QueuedConnection);
    this->Internals->TcpNotificationServer->close();
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onAccept()
{
}
//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onStart()
{
  // normal client server operation uses a proxy
  if (!this->ClientSideZeq()) {
    this->referenceProxy()->getProxy()->InvokeCommand("Start");
  }
  // special gui mode create a local vtkZeqManager
  else {
    this->ClientSideZeqReady();
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onNotified()
{
  int error = 0;
  qint64 bytes_read = 0;
  //
  const zeq::uint128_t new_connection = zeq::make_uint128("zeq::hbp::NewConnection");
  //
  std::stringstream temp;
  //
  vtkZeqManager::event_data event_data;
  //
  while (this->Internals->TcpNotificationSocket->size() > 0) {
    std::cout << "bytes available " << this->Internals->TcpNotificationSocket->bytesAvailable() << std::endl;
    temp << this->Internals->event_num++ << " : ";
    // read event block
    bytes_read = this->Internals->TcpNotificationSocket->read(
      reinterpret_cast<char*>(&event_data), sizeof(vtkZeqManager::event_data));
    if (bytes_read != sizeof(vtkZeqManager::event_data)) {
      error = 1;
      temp << "read " << bytes_read << " bytes of data";
      break;
    }

    // read the remainder of the event data
    std::vector<char> buffer;
    if (event_data.Type == new_connection ||
        event_data.Type == zeq::hbp::EVENT_CAMERA ||
        event_data.Type == zeq::hbp::EVENT_SELECTEDIDS)
    {
      std::cout << "Get a recognized message type " << std::endl;
    }
    else {
      error = 1;
      temp << "Unrecognized/Unsupported event " << event_data.Type;
    }
    // process the event
    if (event_data.Type == new_connection) {
      temp << "New Zeq connection";
      this->Internals->eventview->setModel(&this->Internals->listModel);
    }
    // if (this->Internals->DsmProxyCreated() && this->Internals->DsmInitialized) {
    else if (event_data.Type == zeq::hbp::EVENT_CAMERA) {
      temp << "New Camera";
        //emit this->UpdateData();
    }
    else if (event_data.Type == zeq::hbp::EVENT_SELECTEDIDS) {
      temp << "New Selected Ids : size ";
      temp << event_data.Size;
      if (event_data.Size>0) {
        std::cout << "Event data being read " << event_data.Size*sizeof(int) << std::endl;
        buffer.resize(event_data.Size*sizeof(int));
        bytes_read = this->Internals->TcpNotificationSocket->read(
                       reinterpret_cast<char*>(&buffer[0]), event_data.Size*sizeof(int));
        if (bytes_read!=event_data.Size*sizeof(int)) {
          temp << "Error in data size";
          continue;
        }
      }
      this->UpdateSelection(event_data, &buffer[0]);
    }
    this->Internals->listModel << temp.str().c_str();
    this->Internals->eventview->scrollToBottom();

    if (!error) {
      // read data for event itself
      std::cout << "Updated" << std::endl;
    }
      // TODO steered objects are not updated for now
      // this->Internals->DsmProxy->InvokeCommand("UpdateSteeredObjects");

    // signal back to the server that we have done with this event and it can proceed with the next
    this->referenceProxy()->getProxy()->InvokeCommand("SignalUpdated");
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::UpdateSelection(const vtkZeqManager::event_data &event_data, char *data)
{
  pqServerManagerModel *sm = pqApplicationCore::instance()->getServerManagerModel();
  QList<pqPipelineSource*> pqsources = sm->findItems<pqPipelineSource*>(NULL);
  vtkSMSourceProxy *proxy = NULL;
  if (pqsources.size()>0) {
    std::regex bbp("BlueConfig.*");
    for (QList<pqPipelineSource*>::iterator it = pqsources.begin(); it != pqsources.end(); ++it) {
      proxy = (*it)->getSourceProxy();
      if (std::regex_match((*it)->getSMName().toLatin1().data(), bbp)) {
        this->Internals->listModel << "Setting Ids on " + (*it)->getSMName();
        this->Internals->eventview->scrollToBottom();

        //
        vtkSMProperty *GIDs = proxy->GetProperty("SelectedGIds");
        int numValues = event_data.Size;
        vtkClientServerStream::Array array =
        {
          vtkClientServerStream::int32_array,
          static_cast<vtkTypeUInt32>(numValues),
          static_cast<vtkTypeUInt32>(sizeof(vtkClientServerStream::int32_value)*numValues),
          (int*)(data)
        };

        vtkClientServerStream stream;
        stream << vtkClientServerStream::Invoke
          << VTKOBJECT(proxy)
          << "SetSelectedGIds"
          << numValues
          << array;
        stream << vtkClientServerStream::End;

        proxy->GetSession()->ExecuteStream(proxy->GetLocation(), stream);

        proxy->Modified();
        UpdateViews(proxy);
      }
    }
  }
  else {
    this->Internals->listModel << "No BBP source proxy to set Ids on";
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::GetViewsForPipeline(vtkSMSourceProxy *source, std::set<pqView*> &viewlist)
{
  // find the pipeline associated with this source
  pqPipelineSource* pqsource = pqApplicationCore::instance()->
    getServerManagerModel()->findItem<pqPipelineSource*>(source);
  // and find all views it is present in
  if (pqsource) {
    foreach (pqView *view, pqsource->getViews()) {
      pqDataRepresentation *repr = pqsource->getRepresentation(0, view);
      if (repr && repr->isVisible()) {
        // add them to the list
        repr->getInput()->updatePipeline();
        viewlist.insert(view);
      }
    }
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::UpdateViews(vtkSMSourceProxy *proxy)
{
  std::set<pqView*> viewlist;
  proxy->MarkDirty(proxy);
  GetViewsForPipeline(proxy, viewlist);
  //
  // Update all views which are associated with out pipelines
  //
  for (std::set<pqView*>::iterator it=viewlist.begin(); it!=viewlist.end(); ++it) {
    (*it)->render();
  }
}

//-----------------------------------------------------------------------------
bool pqZeqManagerPanel::ClientSideZeq()
{
  if (this->Internals->zeq_gui->isChecked()) return true;
  return false;
}

//-----------------------------------------------------------------------------
bool pqZeqManagerPanel::ClientSideZeqReady()
{
    if (this->Internals->clientOnlyZeqManager==NULL) {
      this->Internals->clientOnlyZeqManager = vtkZeqManager::New();
      this->Internals->clientOnlyZeqManager->SetClientSideMode(1);
      this->Internals->clientOnlyZeqManager->SetSelectionCallback(
        boost::bind( &pqZeqManagerPanel::onSelectedIds, this, _1 ));
      this->Internals->clientOnlyZeqManager->SetCameraCallback(
        boost::bind( &pqZeqManagerPanel::onHBPCamera, this, _1 ));
      //
      this->Internals->clientOnlyZeqManager->Start();
      //
      this->Internals->listModel << "Client only zeq connection";
      this->Internals->eventview->setModel(&this->Internals->listModel);
      this->Internals->eventview->scrollToBottom();
    }
    return true;
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onHBPCamera( const zeq::Event& event )
{
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onSelectedIds( const zeq::Event& event )
{
  std::vector<unsigned int> Ids2 = zeq::hbp::deserializeSelectedIDs( event );
  unsigned int *Ids = new unsigned int[Ids2.size()];
  std::copy(Ids2.begin(), Ids2.end(), Ids);
  //
  vtkZeqManager::event_data event_data = {event.getType(), Ids2.size() };
  std::stringstream temp;
  temp << "Received Selected Ids " << Ids2.size();
  this->Internals->listModel << temp.str().c_str();
  this->Internals->eventview->scrollToBottom();
  //
  this->UpdateSelection(event_data, (char*)(Ids));
  //
  this->Internals->clientOnlyZeqManager->SignalUpdated();
}
