#include "pqZeqManagerPanel.h"

// Qt includes
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QVariant>
#include <QLabel>
#include <QComboBox>
#include <QTableWidget>
#include <QMessageBox>
#include <QProgressDialog>
#include <QTimer>
#include <QInputDialog>
#include <QFileDialog>
#include <QUrl>
#include <QDesktopServices>
#include <QThread>

// VTK includes

// ParaView Server Manager includes
#include "vtkSMInputProperty.h"
#include "vtkSMProxyManager.h"
#include "vtkSMSourceProxy.h"
#include "vtkSMStringVectorProperty.h"
#include "vtkSMIntVectorProperty.h"
#include "vtkSMArraySelectionDomain.h"
#include "vtkSMProxyProperty.h"
#include "vtkSMViewProxy.h"
#include "vtkSMRepresentationProxy.h"
#include "vtkSMPropertyHelper.h"
#include "vtkProcessModule.h"

// ParaView includes
#include "pqActiveObjects.h"
#include "pqApplicationCore.h"
#include "pqAutoGeneratedObjectPanel.h"
#include "pqSettings.h"
#include "pqOutputPort.h"
#include "pqPipelineSource.h"
#include "pqPropertyLinks.h"
#include "pqProxy.h"
#include "pqServer.h"
#include "pqServerManagerModelItem.h"
#include "pqServerManagerModel.h"
#include "pqSMAdaptor.h"
#include "pqTreeWidgetCheckHelper.h"
#include "pqTreeWidgetItemObject.h"
#include "pqTreeWidget.h"
#include "pqTreeWidgetItem.h"
#include "pqView.h"
#include "pqRenderView.h"
#include "pqDataRepresentation.h"
#include "pqDisplayPolicy.h"
#include "pqAnimationScene.h"
#include "pqPropertyManager.h"
#include "pqNamedWidgets.h"
//
#include <QTcpServer>
#include <QTcpSocket>
#include <QStringListModel>
//
#include "ui_pqZeqManagerPanel.h"
//
#include "vtkZeqManager.h"
#include <zeq/vocabulary.h>
//----------------------------------------------------------------------------
class StringList : public QStringListModel
{
public:
  void append (const QString& string){
    insertRows(rowCount(), 1);
    setData(index(rowCount()-1), string);
  }
  StringList& operator<<(const QString& string){
    append(string);
    return *this;
  }
};

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
class pqZeqManagerPanel::pqInternals : public QObject, public Ui::ZeqManagerPanel
{
public:
  pqInternals(pqZeqManagerPanel* p) : QObject(p)
  {
    this->Links = new pqPropertyLinks;
    event_num = 0;
  }
  //
  ~pqInternals() {
    delete this->Links;
  }
  //
  pqPropertyLinks         *Links;
  QTcpServer*              TcpNotificationServer;
  QTcpSocket*              TcpNotificationSocket;
  StringList               listModel;
  static int               event_num;
};
//----------------------------------------------------------------------------
int pqZeqManagerPanel::pqInternals::event_num = 0;
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
pqZeqManagerPanel::pqZeqManagerPanel(pqProxy* proxy, QWidget* p) :
  pqNamedObjectPanel(proxy, p) 
{
  this->Internals = new pqInternals(this);
  this->Internals->setupUi(this);

  // inherited from pqNamedObjectPanel
  this->linkServerManagerProperties();
  
  this->connect(this->Internals->start,
    SIGNAL(clicked()), this, SLOT(onStart()));

  //
  this->connect(this, SIGNAL(onaccept()), this, SLOT(onAccept()));

  // Create a new notification socket to sned events from server to client
  this->Internals->TcpNotificationServer = new QTcpServer(this);
  this->connect(this->Internals->TcpNotificationServer,
    SIGNAL(newConnection()), SLOT(onNewNotificationSocket()));
  this->Internals->TcpNotificationServer->listen(QHostAddress::Any,
    VTK_ZEQ_MANAGER_DEFAULT_NOTIFICATION_PORT);
}
//----------------------------------------------------------------------------
pqZeqManagerPanel::~pqZeqManagerPanel()
{
}
//-----------------------------------------------------------------------------
void pqZeqManagerPanel::LoadSettings()
{
  pqSettings *settings = pqApplicationCore::instance()->settings();
  settings->beginGroup("ZeqManager");
  /*
  // KernelType
  this->UI->KernelType->setCurrentIndex(settings->value("KernelType", 0).toInt());
  // HCoefficient
  this->UI->HCoefficient->setText(settings->value("HCoefficient", 1.5).toString());
  */
  settings->endGroup();
}
//----------------------------------------------------------------------------
void pqZeqManagerPanel::SaveSettings()
{
  pqSettings *settings = pqApplicationCore::instance()->settings();
  settings->beginGroup("ZeqManager");
  /*
  // KernelType
  settings->setValue("KernelType", this->UI->KernelType->currentIndex());
  // HCoefficient
  settings->setValue("HCoefficient", this->UI->HCoefficient->text());
  */
  settings->endGroup();
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onNewNotificationSocket()
{
  this->Internals->TcpNotificationSocket =
  this->Internals->TcpNotificationServer->nextPendingConnection();

  if (this->Internals->TcpNotificationSocket) {
    this->connect(this->Internals->TcpNotificationSocket,
                  SIGNAL(readyRead()), SLOT(onNotified()), Qt::QueuedConnection);
    this->Internals->TcpNotificationServer->close();
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onAccept()
{
}
//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onStart()
{
    this->referenceProxy()->getProxy()->InvokeCommand("Start");
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onNotified()
{
  int error = 0;
  int bytes = -1;
  zeq::uint128_t notificationCode;
  const zeq::uint128_t new_connection = zeq::make_uint128("zeq::hbp::NewConnection");
  //
  std::stringstream temp;
  //
  while (this->Internals->TcpNotificationSocket->size() > 0) {
    bytes = this->Internals->TcpNotificationSocket->read(
      reinterpret_cast<char*>(&notificationCode), sizeof(notificationCode));
    if (bytes != sizeof(notificationCode)) {
      error = 1;
      std::cerr << "Error when reading from notification socket" << std::endl;
      return;
    }
    temp << this->Internals->event_num++ << " : ";
    if (notificationCode == new_connection) {
      temp << "New Zeq connection";
      this->Internals->eventview->setModel(&this->Internals->listModel);
    }
    // if (this->Internals->DsmProxyCreated() && this->Internals->DsmInitialized) {
    else if (notificationCode == zeq::hbp::EVENT_CAMERA) {
      temp << "New Camera";
      //emit this->UpdateData();
    }
    else if (notificationCode == zeq::hbp::EVENT_SELECTEDIDS) {
      temp << "New Selected Ids";
      //this->UpdateInformation();
    }
    /*
     case zeq::hbp::EVENT_CAMERA:
     std::cout << "\"NONE : ignoring unlock \"...";
     break;
     case zeq::hbp::EVENT_CAMERA:
     std::cout << "\"Wait\"...";
     this->onPause();
     this->Internals->PauseRequested = false;
     emit this->UpdateStatus("paused");
     break;
     */
    else {
      error = 1;
      temp << "Unrecognized/Unsupported event " << notificationCode;
    }
    this->Internals->listModel << temp.str().c_str();
    this->Internals->eventview->scrollToBottom();

    if (!error) std::cout << "Updated" << std::endl;
    // TODO steered objects are not updated for now
    // this->Internals->DsmProxy->InvokeCommand("UpdateSteeredObjects");

    // signal back to the server that we have done with this event and it can proceed with the next
    this->referenceProxy()->getProxy()->InvokeCommand("SignalUpdated");

  }
}
