#include "pqZeqManagerPanel.h"
//
#include <boost/bind.hpp>
#include <boost/core/null_deleter.hpp>

// Qt includes
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QVariant>
#include <QLabel>
#include <QComboBox>
#include <QTableWidget>
#include <QMessageBox>
#include <QProgressDialog>
#include <QTimer>
#include <QInputDialog>
#include <QFileDialog>
#include <QUrl>
#include <QDesktopServices>
#include <QThread>

// VTK includes

// ParaView Server Manager includes
#include "vtkSMInputProperty.h"
#include "vtkSMProxyManager.h"
#include "vtkSMSourceProxy.h"
#include "vtkSMStringVectorProperty.h"
#include "vtkSMIntVectorProperty.h"
#include "vtkSMArraySelectionDomain.h"
#include "vtkSMProxyProperty.h"
#include "vtkSMViewProxy.h"
#include "vtkSMRepresentationProxy.h"
#include "vtkSMPropertyHelper.h"
#include "vtkProcessModule.h"
#include "vtkClientServerStream.h"
#include "vtkSMSession.h"

// ParaView includes
#include "pqActiveObjects.h"
#include "pqApplicationCore.h"
#include "pqAutoGeneratedObjectPanel.h"
#include "pqSettings.h"
#include "pqOutputPort.h"
#include "pqPipelineSource.h"
#include "pqPropertyLinks.h"
#include "pqProxy.h"
#include "pqServer.h"
#include "pqServerManagerModelItem.h"
#include "pqServerManagerModel.h"
#include "pqSMAdaptor.h"
#include "pqTreeWidgetCheckHelper.h"
#include "pqTreeWidgetItemObject.h"
#include "pqTreeWidget.h"
#include "pqTreeWidgetItem.h"
#include "pqView.h"
#include "pqRenderView.h"
#include "pqDataRepresentation.h"
#include "pqDisplayPolicy.h"
#include "pqAnimationScene.h"
#include "pqPropertyManager.h"
#include "pqNamedWidgets.h"
//
#include <QTcpServer>
#include <QTcpSocket>
#include <QStringListModel>
//
#include "ui_pqZeqManagerPanel.h"
//
#include "vtkZeqManager.h"
#include <zeq/vocabulary.h>
#include <monsteer/streaming/vocabulary.h>
//
#include <vector>
#include <regex>
//
//----------------------------------------------------------------------------
class StringList : public QStringListModel
{
public:
  void append (const QString& string){
    insertRows(rowCount(), 1);
    setData(index(rowCount()-1), string);
  }
  StringList& operator<<(const QString& string){
    append(string);
    return *this;
  }
};

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
class pqZeqManagerPanel::pqInternals : public QObject, public Ui::ZeqManagerPanel
{
public:
  pqInternals(pqZeqManagerPanel* p) : QObject(p)
  {
    this->Links = new pqPropertyLinks;
    this->clientOnlyZeqManager = NULL;
    event_num = 0;
  }
  //
  ~pqInternals() {
    delete this->Links;
    if (this->clientOnlyZeqManager) {
      this->clientOnlyZeqManager->Delete();
    }
  }
  //
  pqPropertyLinks         *Links;
  QTcpServer*              TcpNotificationServer;
  QTcpSocket*              TcpNotificationSocket;
  StringList               listModel;
  static int               event_num;
  vtkZeqManager           *clientOnlyZeqManager;
};

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
int pqZeqManagerPanel::pqInternals::event_num = 0;

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
pqZeqManagerPanel::pqZeqManagerPanel(pqProxy* proxy, QWidget* p) :
  pqNamedObjectPanel(proxy, p) 
{
  this->Internals = new pqInternals(this);
  this->Internals->setupUi(this);

  // inherited from pqNamedObjectPanel
  this->linkServerManagerProperties();
  
  this->connect(this->Internals->start,
    SIGNAL(clicked()), this, SLOT(onStart()));

  //
  this->connect(this, SIGNAL(onaccept()), this, SLOT(onAccept()));

  // Create a new notification socket to send events from server to client
  this->Internals->TcpNotificationServer = new QTcpServer(this);
  this->connect(this->Internals->TcpNotificationServer,
    SIGNAL(newConnection()), SLOT(onNewNotificationSocket()));
  this->Internals->TcpNotificationServer->listen(QHostAddress::Any,
    VTK_ZEQ_MANAGER_DEFAULT_NOTIFICATION_PORT);

  QObject::connect(this, SIGNAL(doUpdateGUIMessage(const QString&)),
    this, SLOT(onUpdateGUIMessage(const QString&)));

  QObject::connect(this, SIGNAL(doUpdateRenderViews(vtkSMSourceProxy *)),
    this, SLOT(onUpdateRenderViews(vtkSMSourceProxy *)));

  qRegisterMetaType<event_signal>("event_signal");
  QObject::connect(this, SIGNAL(doInvokeStream(event_signal, const QString &, const QString &, const QString &)),
    this, SLOT(onInvokeStream(event_signal, const QString &, const QString &, const QString &)));

  connect(this->Internals->pause, SIGNAL(clicked()), this, SLOT(onPause()));
  connect(&zeq_timer, SIGNAL(timeout()), this, SLOT(onTimerUpdate()));
}
//----------------------------------------------------------------------------
pqZeqManagerPanel::~pqZeqManagerPanel()
{
}
//-----------------------------------------------------------------------------
void pqZeqManagerPanel::LoadSettings()
{
  pqSettings *settings = pqApplicationCore::instance()->settings();
  settings->beginGroup("ZeqManager");

  // Autostart
  this->Internals->autostart->setChecked(settings->value("autostart", true).toBool());
  // mode
  this->Internals->zeq_both->setChecked(settings->value("zeq_both", true).toBool());
  this->Internals->zeq_gui->setChecked(settings->value("zeq_gui", true).toBool());
  this->Internals->zeq_server->setChecked(settings->value("zeq_server", true).toBool());

  this->Internals->buffertime->setValue(settings->value("zeq_buffertime", 1.0).toDouble());

  settings->endGroup();
}
//----------------------------------------------------------------------------
void pqZeqManagerPanel::SaveSettings()
{
  pqSettings *settings = pqApplicationCore::instance()->settings();
  settings->beginGroup("ZeqManager");

  // Autostart
  settings->setValue("autostart", this->Internals->autostart->isChecked());
  // mode
  settings->setValue("zeq_both", this->Internals->zeq_both->isChecked());
  settings->setValue("zeq_gui", this->Internals->zeq_gui->isChecked());
  settings->setValue("zeq_server", this->Internals->zeq_server->isChecked());
  settings->setValue("zeq_buffertime", this->Internals->buffertime->value());
  settings->endGroup();
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::AutoStart()
{
  if (this->Internals->autostart->isChecked()) {
    this->onStart();
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onNewNotificationSocket()
{
  this->Internals->TcpNotificationSocket =
  this->Internals->TcpNotificationServer->nextPendingConnection();

  if (this->Internals->TcpNotificationSocket) {
    this->connect(this->Internals->TcpNotificationSocket,
                  SIGNAL(readyRead()), SLOT(onNotified()), Qt::QueuedConnection);
    this->Internals->TcpNotificationServer->close();
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onAccept()
{
}
//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onStart()
{
  // normal client server operation uses a proxy
  if (!this->ClientSideZeq()) {
    this->referenceProxy()->getProxy()->InvokeCommand("Start");
  }
  // special gui mode create a local vtkZeqManager
  else {
    this->ClientSideZeqReady();
  }
  this->onPause();
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onPause()
{
  if (!this->Internals->pause->isChecked()) {
    zeq_timer.setInterval(this->Internals->buffertime->value()*1000);
    zeq_timer.start();
  }
  else {
    zeq_timer.stop();
  }
}
//-----------------------------------------------------------------------------
//
// @TODO, clean this up so that the message from zeq is forwarded directly
// to the GUI and then deserialized once in the relevant function
//
void pqZeqManagerPanel::onNotified()
{
  int error = 0;
  qint64 bytes_read = 0;
  //
  const zeq::uint128_t new_connection = zeq::make_uint128("zeq::hbp::NewConnection");
  //
  vtkZeqManager::event_data event_data;
  //
  while (this->Internals->TcpNotificationSocket->size() > 0) {

    //
    std::stringstream temp;
    temp << this->Internals->event_num++ << " : ";

    // read event block
    bytes_read = this->Internals->TcpNotificationSocket->read(
      reinterpret_cast<char*>(&event_data), sizeof(vtkZeqManager::event_data));
    if (bytes_read != sizeof(vtkZeqManager::event_data)) {
      error = 1;
      temp << "Error in data header size";
      break;
    }

    // read data block
    std::vector<char> buffer;
    //
    buffer.resize(event_data.Size);
    bytes_read = this->Internals->TcpNotificationSocket->read(
                   reinterpret_cast<char*>(&buffer[0]), event_data.Size);
    if (bytes_read!=event_data.Size) {
      temp << "Error in data block size";
      continue;
    }

    // process the event
    if (event_data.Type == new_connection) {
      this->Internals->eventview->setModel(&this->Internals->listModel);
      emit doUpdateGUIMessage(QString(temp.str().c_str()) + "New Zeq connection");
    }
    // if (this->Internals->DsmProxyCreated() && this->Internals->DsmInitialized) {
    else if (event_data.Type == zeq::hbp::EVENT_CAMERA) {
      emit doUpdateGUIMessage(QString(temp.str().c_str()) + "CameraEvent");
      this->UpdateCamera(event_data.Type, buffer.data(), buffer.size());
    }
    else if (event_data.Type == zeq::hbp::EVENT_SELECTEDIDS) {
      this->UpdateSelection(event_data.Type, buffer.data(), buffer.size());
    }
    else if (event_data.Type == monsteer::streaming::EVENT_SPIKES) {
      this->UpdateSpikes(event_data.Type, buffer.data(), buffer.size());
    }

    // signal back to the server that we have done with this event and it can proceed with the next
    this->referenceProxy()->getProxy()->InvokeCommand("SignalUpdated");
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::UpdateSelection(zeq::uint128_t Type, const void *buffer, size_t size)
{
  zeq::Event event(Type);
  event.setData(zeq::ConstByteArray((uint8_t*)(buffer), boost::null_deleter()), size);
  //std::cout << "Got a Selected Ids event " << event.getType() << std::endl;
  std::vector<unsigned int> Ids = zeq::hbp::deserializeSelectedIDs( event );
  //
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::UpdateCamera(zeq::uint128_t Type, const void *buffer, size_t size)
{
  emit doUpdateGUIMessage("Setting camera");
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::UpdateSpikes(zeq::uint128_t Type, const void *buffer, size_t size)
{
  emit doUpdateGUIMessage("Setting spikes");
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::GetViewsForPipeline(vtkSMSourceProxy *source, std::set<pqView*> &viewlist)
{
  // find the pipeline associated with this source
  pqPipelineSource* pqsource = pqApplicationCore::instance()->
    getServerManagerModel()->findItem<pqPipelineSource*>(source);
  // and find all views it is present in
  if (pqsource) {
    foreach (pqView *view, pqsource->getViews()) {
      pqDataRepresentation *repr = pqsource->getRepresentation(0, view);
      if (repr && repr->isVisible()) {
        // add them to the list
        viewlist.insert(view);
      }
    }
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::UpdateViews(vtkSMSourceProxy *proxy)
{
  std::set<pqView*> viewlist;
  this->GetViewsForPipeline(proxy, viewlist);
  //
  // Update all views which are associated with out pipelines
  //
  for (std::set<pqView*>::iterator it=viewlist.begin(); it!=viewlist.end(); ++it) {
    (*it)->forceRender();
  }
}

//-----------------------------------------------------------------------------
bool pqZeqManagerPanel::ClientSideZeq()
{
  if (this->Internals->zeq_gui->isChecked()) return true;
  return false;
}

//-----------------------------------------------------------------------------
bool pqZeqManagerPanel::ClientSideZeqReady()
{
    if (this->Internals->clientOnlyZeqManager==NULL) {
      this->Internals->clientOnlyZeqManager = vtkZeqManager::New();
      this->Internals->clientOnlyZeqManager->SetClientSideMode(1);
      this->Internals->clientOnlyZeqManager->SetSelectionCallback(
        boost::bind( &pqZeqManagerPanel::onSelectedIds, this, _1 ));
      this->Internals->clientOnlyZeqManager->SetCameraCallback(
        boost::bind( &pqZeqManagerPanel::onHBPCamera, this, _1 ));
      this->Internals->clientOnlyZeqManager->SetSpikeCallback(
        boost::bind( &pqZeqManagerPanel::onSpike, this, _1 ));
      //
      this->Internals->clientOnlyZeqManager->Start();
      //
      this->Internals->eventview->setModel(&this->Internals->listModel);
      this->Internals->listModel << "Client only zeq connection";
      this->Internals->eventview->scrollToBottom();
    }
    return true;
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onSpike( const zeq::Event& event )
{
  if (!this->Internals->pause->isChecked()) {
    size_t N;
    {
      QMutexLocker lock(&zeq_mutex);
      monsteer::streaming::SpikeMap LocalSpikes;
      LocalSpikes = monsteer::streaming::deserializeSpikes( event );
      Spikes.insert(LocalSpikes.begin(), LocalSpikes.end());
      N = LocalSpikes.size();
      emit doUpdateGUIMessage("Locally buffered " + QString::number(N) + " spikes");
    }
  }
  else {
    emit doUpdateGUIMessage("Skipped spike message (paused)");
  }
  this->Internals->clientOnlyZeqManager->SignalUpdated();
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onHBPCamera( const zeq::Event& event )
{
  // not currently implemented
  emit doUpdateGUIMessage("Received camera data ");
  //
  this->Internals->clientOnlyZeqManager->SignalUpdated();
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onSelectedIds( const zeq::Event& event )
{
  event_signal signal_data = event_signal(new zeq_event);
  signal_data->buffer = new char[event.getSize()];
  std::memcpy(signal_data->buffer, event.getData(), event.getSize());
  signal_data->size   = event.getSize();
  signal_data->Type   = event.getType();
  emit doInvokeStream(signal_data, "BlueConfig.*", "SetSelectedGIds", "ClearSelectedGIds");
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onUpdateGUIMessage(const QString &msg)
{
  this->Internals->listModel << msg;
  this->Internals->eventview->scrollToBottom();
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onUpdateRenderViews(vtkSMSourceProxy *proxy)
{
  this->UpdateViews(proxy);
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onInvokeStream(event_signal e, const QString &regex, const QString &s1, const QString &s2)
{
  if (this->Internals->pause->isChecked()) {
    emit doUpdateGUIMessage("Ignored an event (paused)");
    // after message has been sent we can signal we are ready for the next
    this->Internals->clientOnlyZeqManager->SignalUpdated();
    return;
  }
  //
  int numValues;
  std::vector<unsigned int> Ids;
  monsteer::streaming::SpikeMap Spikes;
  bool signal = false;
  //
  servus::uint128_t t = e->Type;
  zeq::Event new_event(t);
  new_event.setData(zeq::ConstByteArray((uint8_t*)(e->buffer), boost::null_deleter()), e->size);
  //
  pqServerManagerModel *sm = pqApplicationCore::instance()->getServerManagerModel();
  QList<pqPipelineSource*> pqsources = sm->findItems<pqPipelineSource*>(NULL);
  vtkSMSourceProxy *proxy = NULL;
  if (pqsources.size()>0) {
    std::regex bbp(regex.toLatin1().data());
    for (QList<pqPipelineSource*>::iterator it = pqsources.begin(); it != pqsources.end(); ++it) {
      proxy = (*it)->getSourceProxy();
      if (std::regex_match((*it)->getSMName().toLatin1().data(), bbp)) {
        //
        vtkClientServerStream stream;
        if (e->Type == zeq::hbp::EVENT_SELECTEDIDS) {
          Ids = std::move(zeq::hbp::deserializeSelectedIDs( new_event ));
          numValues = Ids.size();
          emit doUpdateGUIMessage(QString("Calling ") + (numValues>0?s1:s2) + QString(" on ")
            + (*it)->getSMName() + " " +  QString::number(numValues));
          if (numValues>0) {
            stream << vtkClientServerStream::Invoke
              << VTKOBJECT(proxy)
              << s1.toLatin1().data()
              << static_cast<int>(numValues)
              << stream.InsertArray((unsigned int*)(&Ids[0]), static_cast<int>(numValues));
            stream << vtkClientServerStream::End;
          }
          else {
            stream << vtkClientServerStream::Invoke
              << VTKOBJECT(proxy)
              << s2.toLatin1().data()
              << vtkClientServerStream::End;
          }
          signal = true;
        }
        else if (e->Type == monsteer::streaming::EVENT_SPIKES) {
          Spikes = std::move(monsteer::streaming::deserializeSpikes( new_event ));
          numValues = Spikes.size();
          typedef std::tuple<uint32_t, float> spike_tuple_type;
          std::vector< spike_tuple_type > spikelist;
          spikelist.reserve(numValues);
          for (auto const &s : Spikes) {
            spikelist.push_back( std::make_tuple(s.second, s.first) );
            std::cout << s.first << ", ";
          }
          float _lastTimeStamp;
          if ( !Spikes.empty() ) {
            _lastTimeStamp = Spikes.rbegin()->first;
          }
          emit doUpdateGUIMessage(QString("Calling ") + (numValues>0?s1:s2) + QString(" on ")
            + (*it)->getSMName() + " " + QString::number(numValues));
          if (numValues>0) {
            stream << vtkClientServerStream::Invoke
              << VTKOBJECT(proxy)
              << s1.toLatin1().data()
              << static_cast<int>(numValues*sizeof(spike_tuple_type))
              << stream.InsertArray((char*)(spikelist.data()), static_cast<int>(numValues*sizeof(spike_tuple_type)));
            stream << vtkClientServerStream::End;
          }
          else {
            stream << vtkClientServerStream::Invoke
              << VTKOBJECT(proxy)
              << s2.toLatin1().data()
              << vtkClientServerStream::End;
          }
        }
        proxy->GetSession()->ExecuteStream(proxy->GetLocation(), stream);
        (*it)->setModifiedState(pqProxy::ModifiedState::MODIFIED);
        proxy->Modified();
        proxy->MarkDirty(NULL);
        emit doUpdateRenderViews(proxy);
      }
    }
  }
  else {
    emit doUpdateGUIMessage("No BBP source proxy to set data on");
  }
  // after message has been sent we can signal we are ready for the next
  if (signal) this->Internals->clientOnlyZeqManager->SignalUpdated();
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onTimerUpdate()
{
  QMutexLocker lock(&zeq_mutex);
  if (Spikes.size()==0) {
    return;
  }
  doUpdateGUIMessage("Timer Update : sending " + QString::number(Spikes.size()) + " spikes");
  zeq::Event event = monsteer::streaming::serializeSpikes( Spikes );
  //
  event_signal signal_data = event_signal(new zeq_event);
  signal_data->buffer = new char[event.getSize()];
  std::memcpy(signal_data->buffer, event.getData(), event.getSize());
  signal_data->size   = event.getSize();
  signal_data->Type   = event.getType();
  doInvokeStream(signal_data, "NeuronSpike.*", "SetSpikeData", "ClearSpikeData");
  //
  Spikes.clear();
}
