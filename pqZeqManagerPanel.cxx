#include "pqZeqManagerPanel.h"

// Qt includes
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QVariant>
#include <QLabel>
#include <QComboBox>
#include <QTableWidget>
#include <QMessageBox>
#include <QProgressDialog>
#include <QTimer>
#include <QInputDialog>
#include <QFileDialog>
#include <QUrl>
#include <QDesktopServices>
#include <QThread>

// VTK includes

// ParaView Server Manager includes
#include "vtkSMInputProperty.h"
#include "vtkSMProxyManager.h"
#include "vtkSMSourceProxy.h"
#include "vtkSMStringVectorProperty.h"
#include "vtkSMIntVectorProperty.h"
#include "vtkSMArraySelectionDomain.h"
#include "vtkSMProxyProperty.h"
#include "vtkSMViewProxy.h"
#include "vtkSMRepresentationProxy.h"
#include "vtkSMPropertyHelper.h"
#include "vtkProcessModule.h"
#include "vtkClientServerStream.h"
#include "vtkSMSession.h"

// ParaView includes
#include "pqActiveObjects.h"
#include "pqApplicationCore.h"
#include "pqAutoGeneratedObjectPanel.h"
#include "pqSettings.h"
#include "pqOutputPort.h"
#include "pqPipelineSource.h"
#include "pqPropertyLinks.h"
#include "pqProxy.h"
#include "pqServer.h"
#include "pqServerManagerModelItem.h"
#include "pqServerManagerModel.h"
#include "pqSMAdaptor.h"
#include "pqTreeWidgetCheckHelper.h"
#include "pqTreeWidgetItemObject.h"
#include "pqTreeWidget.h"
#include "pqTreeWidgetItem.h"
#include "pqView.h"
#include "pqRenderView.h"
#include "pqDataRepresentation.h"
#include "pqDisplayPolicy.h"
#include "pqAnimationScene.h"
#include "pqPropertyManager.h"
#include "pqNamedWidgets.h"
//
#include <QTcpServer>
#include <QTcpSocket>
#include <QStringListModel>
//
#include "ui_pqZeqManagerPanel.h"
//
#include "vtkZeqManager.h"
#include <zeq/vocabulary.h>
//
#include <vector>
//
//----------------------------------------------------------------------------
class StringList : public QStringListModel
{
public:
  void append (const QString& string){
    insertRows(rowCount(), 1);
    setData(index(rowCount()-1), string);
  }
  StringList& operator<<(const QString& string){
    append(string);
    return *this;
  }
};

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
class pqZeqManagerPanel::pqInternals : public QObject, public Ui::ZeqManagerPanel
{
public:
  pqInternals(pqZeqManagerPanel* p) : QObject(p)
  {
    this->Links = new pqPropertyLinks;
    event_num = 0;
  }
  //
  ~pqInternals() {
    delete this->Links;
  }
  //
  pqPropertyLinks         *Links;
  QTcpServer*              TcpNotificationServer;
  QTcpSocket*              TcpNotificationSocket;
  StringList               listModel;
  static int               event_num;
};
//----------------------------------------------------------------------------
int pqZeqManagerPanel::pqInternals::event_num = 0;
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
pqZeqManagerPanel::pqZeqManagerPanel(pqProxy* proxy, QWidget* p) :
  pqNamedObjectPanel(proxy, p) 
{
  this->Internals = new pqInternals(this);
  this->Internals->setupUi(this);

  // inherited from pqNamedObjectPanel
  this->linkServerManagerProperties();
  
  this->connect(this->Internals->start,
    SIGNAL(clicked()), this, SLOT(onStart()));

  //
  this->connect(this, SIGNAL(onaccept()), this, SLOT(onAccept()));

  // Create a new notification socket to sned events from server to client
  this->Internals->TcpNotificationServer = new QTcpServer(this);
  this->connect(this->Internals->TcpNotificationServer,
    SIGNAL(newConnection()), SLOT(onNewNotificationSocket()));
  this->Internals->TcpNotificationServer->listen(QHostAddress::Any,
    VTK_ZEQ_MANAGER_DEFAULT_NOTIFICATION_PORT);
}
//----------------------------------------------------------------------------
pqZeqManagerPanel::~pqZeqManagerPanel()
{
}
//-----------------------------------------------------------------------------
void pqZeqManagerPanel::LoadSettings()
{
  pqSettings *settings = pqApplicationCore::instance()->settings();
  settings->beginGroup("ZeqManager");
  /*
  // KernelType
  this->UI->KernelType->setCurrentIndex(settings->value("KernelType", 0).toInt());
  // HCoefficient
  this->UI->HCoefficient->setText(settings->value("HCoefficient", 1.5).toString());
  */
  settings->endGroup();
}
//----------------------------------------------------------------------------
void pqZeqManagerPanel::SaveSettings()
{
  pqSettings *settings = pqApplicationCore::instance()->settings();
  settings->beginGroup("ZeqManager");
  /*
  // KernelType
  settings->setValue("KernelType", this->UI->KernelType->currentIndex());
  // HCoefficient
  settings->setValue("HCoefficient", this->UI->HCoefficient->text());
  */
  settings->endGroup();
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onNewNotificationSocket()
{
  this->Internals->TcpNotificationSocket =
  this->Internals->TcpNotificationServer->nextPendingConnection();

  if (this->Internals->TcpNotificationSocket) {
    this->connect(this->Internals->TcpNotificationSocket,
                  SIGNAL(readyRead()), SLOT(onNotified()), Qt::QueuedConnection);
    this->Internals->TcpNotificationServer->close();
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onAccept()
{
}
//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onStart()
{
    this->referenceProxy()->getProxy()->InvokeCommand("Start");
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::onNotified()
{
  int error = 0;
  qint64 bytes_read = 0;
  //
  const zeq::uint128_t new_connection = zeq::make_uint128("zeq::hbp::NewConnection");
  //
  std::stringstream temp;
  //
  vtkZeqManager::event_data event_data;
  //
  while (this->Internals->TcpNotificationSocket->size() > 0) {
    std::cout << "bytes available " << this->Internals->TcpNotificationSocket->bytesAvailable() << std::endl;
    temp << this->Internals->event_num++ << " : ";
    // read event block
    bytes_read = this->Internals->TcpNotificationSocket->read(
      reinterpret_cast<char*>(&event_data), sizeof(vtkZeqManager::event_data));
    if (bytes_read != sizeof(vtkZeqManager::event_data)) {
      error = 1;
      temp << "read " << bytes_read << " bytes of data";
      break;
    }

    // read the remainder of the event data
    std::vector<char> buffer;
    if (event_data.Type == new_connection ||
        event_data.Type == zeq::hbp::EVENT_CAMERA ||
        event_data.Type == zeq::hbp::EVENT_SELECTEDIDS)
    {
      std::cout << "Get a recognized message type " << std::endl;
    }
    else {
      error = 1;
      temp << "Unrecognized/Unsupported event " << event_data.Type;
    }
    // process the event
    if (event_data.Type == new_connection) {
      temp << "New Zeq connection";
      this->Internals->eventview->setModel(&this->Internals->listModel);
    }
    // if (this->Internals->DsmProxyCreated() && this->Internals->DsmInitialized) {
    else if (event_data.Type == zeq::hbp::EVENT_CAMERA) {
      temp << "New Camera";
        //emit this->UpdateData();
    }
    else if (event_data.Type == zeq::hbp::EVENT_SELECTEDIDS) {
      temp << "New Selected Ids : size ";
      temp << event_data.Size;
      if (event_data.Size>0) {
        std::cout << "Event data being read " << event_data.Size*sizeof(int) << std::endl;
        buffer.resize(event_data.Size*sizeof(int));
        bytes_read = this->Internals->TcpNotificationSocket->read(
                       reinterpret_cast<char*>(&buffer[0]), event_data.Size*sizeof(int));
        if (bytes_read!=event_data.Size*sizeof(int)) {
          temp << "Error in data size";
          continue;
        }
      }
      this->UpdateSelection(event_data, &buffer[0]);
    }
    this->Internals->listModel << temp.str().c_str();
    this->Internals->eventview->scrollToBottom();

    if (!error) {
      // read data for event itself
      std::cout << "Updated" << std::endl;
    }
      // TODO steered objects are not updated for now
      // this->Internals->DsmProxy->InvokeCommand("UpdateSteeredObjects");

    // signal back to the server that we have done with this event and it can proceed with the next
    this->referenceProxy()->getProxy()->InvokeCommand("SignalUpdated");
  }
}

//-----------------------------------------------------------------------------
void pqZeqManagerPanel::UpdateSelection(const vtkZeqManager::event_data &event_data, char *data)
{
  pqServerManagerModel *sm = pqApplicationCore::instance()->getServerManagerModel();
  pqPipelineSource *pqsource = sm->findItem<pqPipelineSource*>("BlueConfigcircuitreader1");
  vtkSMSourceProxy *proxy = NULL;
  if (pqsource) {
    this->Internals->listModel << "Found a reader object";
    this->Internals->eventview->scrollToBottom();
    proxy = pqsource->getSourceProxy();
  }
  if (proxy) {
    //
    vtkSMProperty *GIDs = proxy->GetProperty("SelectedGIds");
    int numValues = event_data.Size;
    vtkClientServerStream::Array array =
    {
      vtkClientServerStream::int32_array,
      static_cast<vtkTypeUInt32>(numValues),
      static_cast<vtkTypeUInt32>(sizeof(vtkClientServerStream::int32_value)*numValues),
      (int*)(data)
    };

    vtkClientServerStream stream;
    stream << vtkClientServerStream::Invoke
      << VTKOBJECT(proxy)
      << "SetSelectedGIds"
      << numValues
      << array;
    stream << vtkClientServerStream::End;

    proxy->GetSession()->ExecuteStream(proxy->GetLocation(), stream);
  }
  else {
    this->Internals->listModel << "No BBP source proxy to set Ids on";
  }

/*
  // find the pipeline associated with this source
  pqPipelineSource* pqsource = pqApplicationCore::instance()->
  getServerManagerModel()->findItem<pqPipelineSource*>(source);
  // and find all views it is present in
  if (pqsource) {
    foreach (pqView *view, pqsource->getViews()) {
      pqDataRepresentation *repr = pqsource->getRepresentation(0, view);
      if (repr && repr->isVisible()) {
        // add them to the list
        viewlist.insert(view);
      }
    }
  }
 */
}
